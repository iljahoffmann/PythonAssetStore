import os
from bs4 import BeautifulSoup
from lib.fsutil import text_file_content


def pretty_html(html_fragment, stripped_body=True):
	'''
	Prettiy HTML. If stripped_body is True, html_fragment is expected to
	not contain a html, head or body tag.
	:param html_fragment: unformatted html text
	:param stripped_body: if set to true (default), prettify, then strip the body tag generated by html5lib
	:return: prettified html(-fragment)
	'''
	soup = BeautifulSoup(html_fragment, 'html5lib')
	pretty_with_body = soup.body.prettify(formatter='html5')
	if stripped_body:
		stripped= '\n'.join(pretty_with_body.splitlines()[1:-1])
		return stripped
	else:
		return pretty_with_body


def _attributes(**kwargs):
	def _substitude(key, real_key):
		if key in kwargs:
			value = kwargs[key]
			del kwargs[key]
			kwargs[real_key] = value

	_substitude('_class', 'class')
	_substitude('class_', 'class')
	_substitude('_id', 'id')
	_substitude('id_', 'id')
	_substitude('_for', 'for')
	_substitude('for_', 'for')

	if 'unnamed' in kwargs:
		if kwargs['unnamed'] is not None:
			unnamed = ' ' + ' '.join(kwargs['unnamed'])
		else:
			unnamed = ''
		del kwargs['unnamed']
	else:
		unnamed = ''

	formatted = list(map(lambda k: '{}="{}"'.format(k.replace('_', '-'), kwargs[k]), kwargs))
	if len(formatted) == 0:
		return unnamed
	else:
		return ' {}{}'.format(' '.join(formatted), unnamed)


def _join_content(*_content):
	if _content is None or len(_content) == 0:
		return ''

	if len(_content) > 1:
		return '\n'.join(_content)
	else:
		return _content[0]


def _std_tag(tag, *_content, **attr):
	return '<{}{}>{}</{}>'.format(tag, _attributes(**attr), _join_content(*_content), tag)


def t_html(*_content, **attr):
	return _std_tag('html', *_content, **attr)


def t_head(*_content, **attr):
	return _std_tag('head', *_content, **attr)


def t_th(*_content, **attr):
	return _std_tag('th', *_content, **attr)


def t_body(*_content, **attr):
	return _std_tag('body', *_content, **attr)


def t_a(*_content, **attr):
	return _std_tag('a', *_content, **attr)


def t_b(*_content, **attr):
	return _std_tag('b', *_content, **attr)


def t_br(*_content, **attr):
	return _std_tag('br', *_content, **attr)


def t_p(*_content, **attr):
	return _std_tag('p', *_content, **attr)


def t_fieldset(*_content, **attr):
	return _std_tag('fieldset', *_content, **attr)


def t_legend(*_content, **attr):
	return _std_tag('legend', *_content, **attr)


def t_table(*_content, **attr):
	return _std_tag('table', *_content, **attr)
	# return '<table{}>{}</table>'.format(_attributes(**attr), _join_content(*_content))


def t_tr(*_content, **attr):
	return _std_tag('tr', *_content, **attr)
	# return '<tr{}>{}</tr>'.format(_attributes(**attr), _join_content(*_content))


def t_td(*_content, **attr):
	return _std_tag('td', *_content, **attr)


def t_td3(*_content, **attr):
	return '<td{} colspan="3">{}</td>'.format(_attributes(**attr), _join_content(*_content))


def t_pre(*_content, **attr):
	return _std_tag('pre', *_content, **attr)


def t_h(level, *_content, **attr):
	return _std_tag(f'h{level}', *_content, **attr)
	# return '<h{}{}>{}</h2>'.format(level, _attributes(**attr), _join_content(*_content))


def t_h1(*_content, **attr):
	return t_h(1, *_content, **attr)


def t_h2(*_content, **attr):
	return t_h(2, *_content, **attr)


def t_h3(*_content, **attr):
	return t_h(3, *_content, **attr)


def t_h4(*_content, **attr):
	return t_h(4, *_content, **attr)


def t_div(*_content, **attr):
	return _std_tag('div', *_content, **attr)


def _append_to_classes(add_to_classes, **attr):
	_class = attr.get('class_', attr.get('_class'))
	_class = f'{_class} ' if _class else ''
	_class = f'{_class}{add_to_classes}'
	return _class


def t_colflex(*_content, **attr):
	return _std_tag('div', *_content, class_=_append_to_classes('colflex', **attr), **attr)


def t_rowflex(*_content, **attr):
	return _std_tag('div', *_content, class_=_append_to_classes('rowflex', **attr), **attr)


def t_href(*_content, **attr):
	return _std_tag('a', *_content, **attr)


def t_button(*_content, **attr):
	return _std_tag('button', *_content, **attr)


def t_input(*_content, **attr):
	return _std_tag('input', *_content, **attr)


def t_checkbox(*_content, **attr):
	box = t_input(*_content, type='checkbox', **attr)
	box_id = attr.get('_id', attr.get('id_'))
	if 'label' in attr and box_id:
		label = t_label(attr['label'], for_=box_id)
		return f'{box}{label}'
	else:
		return box


def t_color_selector(*_content, **attr):
	return t_input(*_content, type='color', **attr)


def t_textarea(*_content, **attr):
	return _std_tag('textarea', *_content, **attr)


def t_script(*_content, **attr):
	return _std_tag('script', *_content, **attr)


def t_style(_content):
	return '<style>{}</style>'.format(_content)


def t_details(summary, *_content, **attr):
	return '<details{}><summary>{}</summary>{}</details>'.format(_attributes(**attr), summary, _join_content(*_content))


def t_label(*_content, **attr):
	return _std_tag('label', *_content, **attr)


def t_span(*_content, **attr):
	return _std_tag('span', *_content, **attr)


def t_img(*_content, **attr):
	return _std_tag('img', *_content, **attr)


def goto_target(text):
	return t_span(text, _class='goto_target')


def make_option(text, value=None):
	if value is None:
		_value = text
	else:
		_value = value

	result = f'<option value="{_value}">{text}</option>'
	return result


def make_control(control_name, replacements=None):
	raise Exception('currently not supported')

	control_path = os.path.join(control_assets_root, control_name)
	if not os.path.isdir(control_path):
		print(f'make_control(): directory not found: {control_path}')
		return None

	code = []
	style = []
	html = []
	parts = []
	code_parts = []

	with os.scandir(control_path) as contents:
		for entry in contents:
			if entry.is_file():
				file = os.path.join(control_path, entry.name)
				if entry.name.endswith('html'):
					html.append(file)
				elif entry.name.endswith('css'):
					style.append(file)
				elif entry.name.endswith('js'):
					code.append(file)

	for n in style:
		parts.append(f"<style>\n{text_file_content(n, replacements=replacements)}\n</style>")

	for n in html:
		parts.append(text_file_content(n, replacements=replacements))

	for n in code:
		code_parts.append(f"<script>\n{text_file_content(n, replacements=replacements)}\n</script>")

	result = '\n'.join(parts)
	code_result = '\n'.join(code_parts)
	return result, code_result
